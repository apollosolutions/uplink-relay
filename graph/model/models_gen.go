// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
)

type Configuration struct {
	// The uplink relay's list of supported supergraphs.
	Supergraphs []*Supergraph `json:"supergraphs"`
	// The URL of the uplink relay.
	URL string `json:"url"`
}

type DeleteCacheEntryInput struct {
	Operation []OperationType `json:"operation"`
	GraphRef  string          `json:"graphRef"`
}

type DeleteCacheEntryResult struct {
	Success       bool           `json:"success"`
	Configuration *Configuration `json:"configuration"`
}

type ForceUpdateInput struct {
	Operations []OperationType `json:"operations"`
	GraphRef   string          `json:"graphRef"`
}

type ForceUpdateResult struct {
	Success       bool           `json:"success"`
	Configuration *Configuration `json:"configuration"`
}

type Mutation struct {
}

type PersistedQueryManifest struct {
	ID                   string   `json:"id"`
	Hash                 string   `json:"hash"`
	PersistedQueryChunks []string `json:"persistedQueryChunks"`
}

type PinPersistedQueryManifestInput struct {
	ID       string `json:"id"`
	GraphRef string `json:"graphRef"`
}

type PinPersistedQueryManifestResult struct {
	Success       bool           `json:"success"`
	Configuration *Configuration `json:"configuration"`
}

type PinSchemaInput struct {
	LaunchID string `json:"launchID"`
	GraphRef string `json:"graphRef"`
}

type PinSchemaResult struct {
	Success       bool           `json:"success"`
	Configuration *Configuration `json:"configuration"`
}

type Query struct {
}

type Schema struct {
	// The ID of the schema.
	ID string `json:"id"`
	// The hash of the schema.
	Hash string `json:"hash"`
	// The schema itself.
	Schema string `json:"schema"`
}

type Supergraph struct {
	// The ID of the uplink relay.
	GraphRef string `json:"graphRef"`
	// The schema ID pinned to the uplink relay.
	// This will be null if the service has not proxied a request with a schema return. Pinned schemas should always have data, as should any schema that's been forced to be fetched (since it'll be in the cache).
	CurrentSchema *Schema `json:"currentSchema,omitempty"`
	// The persisted query manifest ID pinned to the uplink relay.
	// This will be null if the service is not using persisted queries, or if the service has not proxied a request with a persisted query manifest return.
	// Pinned persisted query manifests should always have data, as should any persisted query manifest that's been forced to be fetched (since it'll be in the cache).
	PersistedQueryManifest *PersistedQueryManifest `json:"persistedQueryManifest,omitempty"`
	// The schema ID pinned to the uplink relay.
	// This will be null if the service has not pinned the schema launch ID.
	PinnedLaunchID *string `json:"pinnedLaunchID,omitempty"`
	// The persisted query manifest ID pinned to the uplink relay.
	// This will be null if the service has not pinned the persisted query manifest ID.
	PinnedPersistedQueryManifestID *string `json:"pinnedPersistedQueryManifestID,omitempty"`
}

type HealthStatus string

const (
	HealthStatusOk   HealthStatus = "OK"
	HealthStatusDown HealthStatus = "DOWN"
)

var AllHealthStatus = []HealthStatus{
	HealthStatusOk,
	HealthStatusDown,
}

func (e HealthStatus) IsValid() bool {
	switch e {
	case HealthStatusOk, HealthStatusDown:
		return true
	}
	return false
}

func (e HealthStatus) String() string {
	return string(e)
}

func (e *HealthStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HealthStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HealthStatus", str)
	}
	return nil
}

func (e HealthStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OperationType string

const (
	OperationTypeSchema                 OperationType = "SCHEMA"
	OperationTypeEntitlement            OperationType = "ENTITLEMENT"
	OperationTypePersistedQueryManifest OperationType = "PERSISTED_QUERY_MANIFEST"
)

var AllOperationType = []OperationType{
	OperationTypeSchema,
	OperationTypeEntitlement,
	OperationTypePersistedQueryManifest,
}

func (e OperationType) IsValid() bool {
	switch e {
	case OperationTypeSchema, OperationTypeEntitlement, OperationTypePersistedQueryManifest:
		return true
	}
	return false
}

func (e OperationType) String() string {
	return string(e)
}

func (e *OperationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OperationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OperationType", str)
	}
	return nil
}

func (e OperationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
